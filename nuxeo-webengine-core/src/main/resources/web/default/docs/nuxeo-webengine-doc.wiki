
= Nuxeo WebEngine

{toc}{/toc}

The WebEngine is a framework to build web applications on top of the Nuxeo ECM platform.

== Overview

The main goal for the WebEngine framework is to let users to build web applications quickly and easily and in a traditional way 
without having knowledge on advanced Java topics such as JSF or Seam.

The second goal is to be able to develop web pages while the server is running, without the need of restarting
the server each time the configuration or the code is modified.

The web pages are build using Freemarker templates for the presentation part and optionally scripts 
(like groovy, jython etc) or custom Java request handlers for the logical part.

Thus a web application is made from:
+ *Configuration* - based on the nuxeo extension points mechanism
+ *Templates* - freemarker is used as the template engine
+ *Scripts* - any script supported by java scripting engine.
+ *Custom Java Code* - plugged-in through extension points

Here is an example of a simple template page
{{{My name is ${Context.principal.name}!}}}
that is outputting
{{{My name is Administrator!}}}
if you are logged in as __Administrator__.

The same can be done from a script (in this example a groovy script):

{{{
Context.print("My name is ${Context.principal.name}")!
}}}



=== Bridging with Nuxeo ECM

The WebEngine was created to work over a Nuxeo ECM server. Using it outside Nuxeo ECM is possible, but is very limiting and you will loose many of the cool features of the WebEngine.

If you don't plan to use a Nuxeo ECM server as the content backend for your web site or Web 2.0 application, we suggest you to look at other products that may better fit your needs:
* Django
* Ruby on Rails
* etc.

In this section we will assume you have some knowledge about the Nuxeo ECM platform.

Nuxeo ECM, as its name suggests, is an Enterprise Content Management platform that provides a powerful way to manage and store your documents. For simplicity you can see Nuxeo ECM as a document repository. To use access the repository, to update, query or to store new documents, you need first to connect to it and create an authenticated session based on your login information. Using that repository session you can then start querying, updating and sorting documents.

So, from a client point of view, the main concepts of a Nuxeo Repository are the Session (the user connection to the repository) and the Document (the units of information that are mananged by the repository).

The idea behind the WebEngine is to map HTTP requests to documents stored in the repository and to be able that way to query, update, store or create new documents by using a traditional Web approach.

To correctly understand how this bridging over Nuxeo ECM is done and what you can do by using WebEngine, you should first understand how HTTP requests are dispatched, processed and mapped to documents.



=== Request Dispatch

We will start using a simple example. Let's say the client is requesting the following URL:
`http://www.nuxeo.org/nuxeo/site/repository/blogs/bstefanescu/MyBlog@@view`

First the URL will be split as following:
* `http://www.nuxeo.org` - the server host information
* `/nuxeo/site` - the servlet context path. This corresponds to the Java context path + servlet path. As we are in Java world, we are obviosuly using Java servlets under the hoods. The WebEngine is bound on an unique servlet in a Web Application. You cannot have multiple WebEngines in the same Web Application. If you want to partition your WebEngine sites into different applications you need to use the WebEngine Application concept as we will see later.
In the standalone packaging of WebEngine 9based on Jetty) the servlet context path is the root one: "/".
* `/repository` - the WebEngine application path. This path is used to select te WebEgnine application you want.
* `/blogs/bstefanescu/MyBlog` - the request path. This path is used to select the document or script you want to call.
* `@@view` - the action to take on the selected object. The action is optional and, if ommited when requesting Documents, the implicit action is `@@view`.

The first 2 URL components are not in the scope of this document. They are used to locate the servlet bound to the WebEngine application.

We will focus on the last two URL parts:

+ Application path
+ Request path
+ Action



==== Application Path

The application path is used to select which WebEngine application to use. WebEngine applications are usefull to isolate the different sites you want to host. A single application may define several application paths. When defining an application path you can optionally specify a repository Document that will be selected as the root document when an application is selected.\
More details about this in the WebEngine Application section.


==== Request Path

The request path (aka traversal path) represent the path that should be processed and resolved by the selected web application. If the application path used to select the application defined a Document root then the application will try to map the request path to a Document or a chain of Documents in the repository. If the application path is not bound to a Document root then the application will try to resolve the path to a script or template on the file system. If neither of these methods succeeds an error page (along with a 404 error code) is sent to the client.\
*Note* that in future it will be possible to bound an application path to an arbritrary root Object that is not necesarly a Document in the repository but that will know how to resolve the request path into a chain of arbitrary objects (not necesarly Documents). This is usefull for example to map a request path on an User, Group or other objects managed by Nuxeo ECM.

The default technique to resolve request paths into a chain of Documents is using a direct mapping beetween the request path and a repository path starting from the root Document. The mapping technique is configurable and can be changed by implementing the `org.nuxeo.ecm.webengine.RequestHandler` interface.

Lets give an example on how the default mapping works.

Lets say you defined an application bound to an application path of `/repository` in the context of a WebEngine instance that is bound to a servlet accessible at `http://localhost:8080/nuxeo/site`.  So, a request of the form `http://localhost:8080/nuxeo/site/repository/foo/bar` will be resolved against your application and the URL will be split as following:

+ `http://localhost:8080` - host server
+ `/nuxeo/site` - WebEngine context path (the root context)
+ `/repository` - the application path
+ `/foo/bar` - the request path

Lets say your application path `repository` defines a root document that points to `/default-domain/workspaces/MyWorkspace` (this is a repository path).
Then the application will try to resolve the `/foo/bar` path as a repository path starting from te root Document. So the selected document (the target document of the request) will be one of:

* `/default-domain/workspaces/MyWorkspace` - the root itself
* `/default-domain/workspaces/MyWorkspace/foo` - if `foo` is resolved as a child document of the root but `bar` is not resolved as a child document of `foo`
* `/default-domain/workspaces/MyWorkspace/foo/bar` - if both `foo` and `bar` are resolved as child documents

Let say `foo` is a child of `/default-domain/workspaces/MyWorkspace` and `bar` could not be resolved as a child document of `foo`. Then the request path will be resolved to `/default-domain/workspaces/MyWorkspace/foo` that will be called the *Target Document* (or Context Document) and the remaining segments (the unresolved segments) will define the *trailing path* - in our case `/bar`. The chain of Documents that were obtained by mapping the request path is known as the *traversal objects*.


==== Trailing Path
As we've seen the trailing path contains the `residual` segments after a mapping on a Document is done. Obviously it will be empty if all segments from the request path are mapped to documents. Anyway, such 'residual' path segments are not garbage but they may give some extra information on how to perform the request. How the trailing path is used by the server is depending on the action or script that will be executed on the Target Document. There isn't any default behavior in handling such a trailing path. It is up to the developer how this path is used.
For example a possible usage is to map the trailing path on an XPATH that point to a Document property. So in our previous example the trailing path `/bar` will point to a property `bar` in the document `foo`. This can be used to create paths to set or get properties on documents. Example:
`/default-domain/workspaces/MyWorkspace/foo/bar@@set?value=test` 


==== Actions

The action string represent an action to be taken on the last resolved document (or the target document).

An action can be bound to a Java class (an action handler) or to a script in order to perform the wanted operation on the document.
If no action is specified in the request URL then a default action `@@view` will be used.

*Note* that in future the `action` concept will be extended. For now actions are used when requesting Documents. They are ignored when the request is not resolved to a document but to a script or template. (e.g. if you are using pure scripting that are not resolved to Nuxeo ECM Documents). In future the action mechanism will be extended to be used on any type of resource. For example in the case of scripts an `action` may be mapped on a script function.

You can find more details on actions in Web Application : Actions section



=== Document Mapping

We already seen how the request URL is transformed into these components:
+ host server
+ servlet context
+ application path
+ request path
+ an optional trailing path
+ an optional action

In the examples above we've seen how a request path was mapped on documents. But what if we need more control on the mapping mechanism? As we said one solution (but harder) is to write a custom request handler that is doing the job. Another solution that doesn't requires any additional Java code is to use path mappings.

Mappings can be used to declaratively describe how request paths should be processed to obtain a document chain, a trailing path and additional properties computed from the path segments configuration. Mappings are described using regular expression patterns. The regular expression syntax is the Java one with an additional feature to be able to define named groups. (In Java only indexed groups are supported).

In order to understand how you can use patterns to describe the path mapping we will start with another example.

Lets say we want to use the following URL path:

`/blogs/archive/2004/05`

to display a list of the blogs of user `bstefanescu` created in May 2004. Lets say that we define an application path `/blogs` that specify a root Document `/default-domain/workspaces/blogs` where are stored the blogs in the repository.

So by using a `/blogs` prefix in the URL path we will seclect the correct application so that we have the root `/default-domain/workspaces/blogs`.
Then, we want to use a script that will be invoked in the context of the root document to perform a search like:
{{{SELECT * FROM Blog WHERE ecm:path STARTSWITH ${blogs} AND dc:created >= DATE '$year-$month-01'}}}
to select all the blog documents created after the given date and located under the `${blogs}` document.
For this we need to extract from the input the year and the month information. We already known the `${blogs}` variable since it is the target document of the request (in our case it is the same as the seclected application root).
In order to do this we need to define the following mapping:

{{{/blogs/archive/(?year:[0-9]{4}?)/(?month:[0-9]{2}?)}}}

This mapping is matching any path in the desired format and will inject in the request context the variables `${year}` and `${month}`. This way the script can grab them from the context and run the query.

The syntax (?label: ... ) for regular expression groups is an extension to the Java regular expressions that are supporting only indexed groups. You can still use the indexed groups if you prefer:

`/blogs/archive/([0-9]{4}?)/([0-9]{2}?)`

In this case the generated mapping variables will be `$1` for the year and `$2` for the month.

You may note that using mappings or using a custom request handler that avoid mapping path segments on documents you may create web application that doesn't use any Nuxeo repository.



=== Directory Layout - Resolving Scripts and Templates 

All WebEngine application files are residing under a common root folder named the web folder. This folder is located in `${nxserver}/web` folder in the standalone version. On JBoss the web root folder is located in `${jboss_install_dir}/server/default/data/NXRuntime/web`.

An application may have multiple roots folders where scripts and other files are residing. When resolving scripts from paths each of these folders are consulted in turn until a matching file is found.

Example: Let say you have an web application that contains two roots: `wiki` and `default` (in that order). So inside the `web` directory we will have `web/wiki` and `web/default`.

When resolving a path let say `/commons/myscript.py` the web application will look first in `wiki` folder for a file path `commons/myscript.py` and then if none was found it looks for the same path in the `default` folder. 

This mechanism is completely described in the Directory Stacking section.

Note that the paths `/commons/myscript.py` and `commons/myscript.py` are equivalent. Both of them will be resolved relative to the Web Application root folders.

If you need to use relative paths (relative to the current executed script or template) you must prepend a '.' or a '..' on the path to force the path resolver to use the current script as the file base.

Example of relative paths:
* ../../myscript.py
* ./myscript.groovy

Note that using relative paths is less efficient since the path lookup cannot be cached because the current directory used to resolve scripts depends on the current request context, context that is changing on each request or more may change during the same request.\
Also when a relative path points outside the web root directory then it will be truncated (i.e. trailing ../ removed) and resolved as an absolute path.

==== Resolving Action Scripts

When writing scripts or templates to handle request actions we usually want to treat the target documents of same type in the same manner. For example a `Folder` document will be always displayed as a folder, a `File` document as a file and so on.

So we need a mechanism to select the template or the script associated to an action depending on the target document type.

Note that this selection mechanism make sense only for document action scripts. It doesn't make sense for plain scripts (that are not bound to documents) since in this case you may not have a target document.

This aspect was solved by using a very simple and intuitive mechanism based on folder names:

Each application root folder may contain a sub-folder for each document type. This sub folder should use the same name as the document type.

This way each time an action script is resolved the resolver will look in the folder having the same name as the target document type. If it doesn't find any matching file it is looking in the folder corresponding to the super type of the current document type and so on. This lookup stops when a matching file is found or when no more super types exists.

As the `Document` type is the base types of all Nuxeo document types you may put in that folder the default files for every document action.

If no file matches then a default file (a fallback file) will be used to display a custom message. This default file is configurable at the application level. If the default file cannot be fond or was not defined then a 404 is send to the client.

Example: In the `default` application root you may have three folders:
* Document
* Folder
* Wiki

Let say you want to call the script bound to the `@@view` action of a `Wiki` document. Then the script resolver will first look into `Wiki` folder then if nothing is found and because `Wiki` is extending `Folder` it will look into `Folder` folder and then if nothing is found as `Folder` is extending `Document` it will look into Document folder. Finally if nothing is found the registered default script if any is used.

*Note* that when you have multiple web application roots this mechanism will searching the script in each root in turn until something is found.



== Getting Started

WebEngine is shipped in two flavours:
* a standalone server
* a Nuxeo ECM module, that runs in a JBoss application server

Both of these versions provides the same functionalities and the same JARs are used on both platforms.
This is possible since WebEngine is build over the Nuxeo Runtime layer that works over any OSGi platform.
In both standalone and JBoss versions the OSGi framework is emulated by a Nuxeo component: `nuxeo-runtime-osgi`.



=== Standalone server

The standalone server is the *light* version of WebEngine and doesn't requires an application server to work.
This means that Nuxeo services requried by WebEngine are not exposed as session beans. Anyway, all of the functionalities present in the JBoss version are available in the standalone server.
The light version is embedding a Jetty HTTP server and by default binds the WebEngine instance to the root web context: `/`.\
In the future, we plan to also provide a light version of WebEngine that will embed a GlassFish3 server.

The light version is very usefull for developing since the startup time is very fast (e.g. 2-3 seconds on my laptop using Java6) - but can be also used in production.

==== Installation
To install the light version download it from http://nuxeo.org/projects/webengine, unzip the content into a folder of your choice.
and run `nxserver.sh` to launch the application.

==== Launcher
To start WebEngine simply run `./nxserver.sh` on linux or `nxserver.cmd` on windows.

The common options are:

* `-debug` - to start in debug mode. In this mode the launcher will wait for a Java debuger to connect.
* `-clear` - to cleanup cache before starting. This is needed if you add a JAR into `bundles` or `lib` directories - since the launcher is caching the classpath at the first start of the server.

For more information on the launcher look into `nxserver.sh`

==== Requirements
* Java 5 or later - WebEngine is working fine on both Java 5 and 6.



=== Nuxeo ECM module

WebEngine can be deployed as a Nuxeo ECM module on a running Nuxeo server (that currently supports JBoss as application server).\
In this version, WebEgnine is bound by default to the `/nuxeo/site` context path.

When deployed as a Nuxeo ECM module, WebEngine will run in an application server so all required Nuxeo services will be exposed as session beans.

==== Installation

Install a Nuxeo ECM product. Download the webengine components from http://www.nuxeo.org/projects/webengine:
* nuxeo-platform-rendering
* nuxeo-webengine-core
* nuxeo-webengine-wiki (optional)

Copy these JARs inside nuxeo.ear/plugins

Make sure you have nuxeo-runtime-scripting in your nuxeo.ear/system folder if not download and copy it into this folder.
Make sure you have the following JARs in yout `nuxeo.ear/libs`:
* freemarker-2.3.11.jar
* json-lib-2.2.1-jdk15.jar
* ezmorph-0.9.jar

If they are not there, download them and copy into the `libs` folder (overwriting older versions if any)


==== Requirements
* JBoss 4.0.5 GA
* Nuxeo EP 5.2 - WebEngine is not working with older versions
* Java 5 - WebEngine is also working with Java 6 but other modules in JBoss may not work properly.



== Applications

Now that we've seen the main concepts used to build a web application, we can learn how to configure and assemble them to obtain a working application.
 
A Web  Application is a collection of configuration files, scripts, templates and other resources that is accessible remotely through a servlet. The WebEngine allows the definition of multiple applications. All these application data reside inside the root `web` directory. As we've seen earlier, on JBoss this root directory is located at:

`${jboss_install_dir}/server/default/data/NXRuntime/web`

An application may access any resources within the root `web` directory, but none outside it. This means that several applications may share data and reuse scripts.

Anyway in the term of configuration these application must be isolated to avoid propagating some custom configurations that was done for a given web application to all other existing applications.

Also, to be able to easily select the target application when a request is made, each application will be bound to a different servlet. This way the servlet invocation will automatically select the correct application.

This binding is done at server configuration level in the `web.xml` configuration file by specifying an init-parameter with the name "webapp" and that points to the name of the application to bind to. If no such parameter is defined the following is implied:

{{{
  <init-param>
    <param-name>webapp</param-name>
    <param-value>nuxeo-web</param-value>
  </init-param>
}}}

So, we've seen that a web application should be isolated at configuration level from other applications. This is to avoid propagate customization to other applications. But this doesn't means that application cannot shared some basic and immutable configuration. This can be very useful to avoid redefining some generic configuration for each application.

These requirements, impose a configuration mechanism split in two layers:
+ A generic configuration layer shared between all applications. The configuration from this layer cannot be modified by applications. We will name this layer the *Global Configuration*.
+ An application specific configuration layer that can be used to define specific customizations over the global configuration. This configuration layer will be named *Application Configuration* and should be used to customize applications.

For more details about what can be configured in both configuration layers see the Configuration chapter.

A web application is responsible for:
+ Resolving script or templates paths
+ Managing the custom configuration
+ Resolving path segments to documents
+ Managing the scripting and template engine

Web application data may be contributed by separate OSGi modules (JARs). Usually when a module wants to contribute it's own scripts and templates it is installing these files from the JAR inside the `web` root directory (this is done automatically by using an extension point - we will see this later in Configuration chapter).

It is recommended that modules should contribute files by creating a new directory into the `web` root and not by replacing existing files. The directory stacking mechanism can be used to override existing files if this is wanted. 

=== Directory Stacking

As we've seen earlier in the Overview chapter an application may define several roots inside the web root directory.

These roots are known as the application directory stack and are used to resolve scripts and templates.

Root directories are stacked given a priority so that the resolver will try each root in a the right priority order until a resource is found.

Directory Roots are mainly used to override resources deployed by other modules or to define additional skins for an application. By using the right priority for the root directories in the stack you may obtain the desired effect - override some existing resources but avoid overriding some other ones.

The stack defined at the global level is containing only the `default` directory. This directory comes with scripts and templates that deals with common types in Nuxeo like `File`, `Folder`, `Note`, `Workspace` etc. 

Applications may add new directories to the stack but these will be visible only for the application that defined them. So stacking is not shared between applications.

==== Example

Let's say module nuxeo-webengine-core contributed the `default` directory, nuxeo-webengine-wiki contributed the `wiki` directory and nuxeo-webengine-blogs the `blogs` directory.

The `wiki` folder contains scripts and templates that deals with `Wiki` and `WikiPage` document types, while the `blogs` folder declare the 
Then an application APP1 may use a stack: `wiki`, `default` and another application APP2 may use: `blogs`, `default`.
Both APP1 and APP2  will see the scripts that deal with common Nuxeo types (the ones from `default`) but APP1 will not see blog related scripts and APP2 will not see wiki related scripts.

Using the same mechanism you may change or hide only .css or .gif files creating thus skins.

=== Web Objects

Before talking about Web Objects we will recapitulate some things about traversal paths. We've seen that *request paths* are transformed into a *traversal path* and an *trailing path* (and possibly some matching attributes in the case of a path pattern match).

The generated `traversal path` is a sequence of documents that should be traversed before executing the request. The last document that is traversed (the last in the traversal path) will be set as the target document of the request and the request will be executed in the context of that document.

We've also seen that you may have requests that doesn't generate any traversal path. In this case pure web scripting will be done (outside any document context). Also you should note that the documents in the traversal path are not necessarily the children of each other like in a repository path. The mechanism used to create the traversal path is up to the registered document resolver.

The documents in the traversal path will not be exposed as is in the request context but they will be wrapped inside a high level object web oriented that is called WebOject. THis is needed because the Nuxeo documents are repository oriented, they doesn't have any knowledge about the web context in which they are used. They doesn't know for example what is the URL  used to access them, or what are the web actions that are enabled in the current web context.

For this reason before being exposed in the web context they are wrapped in a web sensitive object.

This means we need to map documents to a high level object that can hold web specific configuration like enabled web actions. 
This mapping can be done either at the global level XXX. 

=== Actions

There are several pre-defined actions in the default webengine configuration. Here is a list of that actions:

+ view
+ print
+ edit
+ delete
+ create
+ update
+ getfile
+ addfile
+ deletefile

An action should be identified using a meaningful verb like 'doSomething' and can specify:
* a class to be used as the action handler
* a script to be invoked on the target document
* an enablement flag to be used to disable / enable the action
* a category that can be used to group actions
* a set of guards to restrict the action execution

Any of these action properties are optional - but the action will be useless if you do not specify one of them.

The first 2 properties the *action handler* and the *script* should be used to specify how the action will be executed.

As you seen you have two options: either using java code (if you want faster or advanced processing) either using a script (possibly a template) that will carry on the action execution. 

You can either use both properties to install a Java action execution handler and a template to be used to show the result of the execution. Or, more, you can install a handler and a groovy script then in the groovy script you may do some post processing and then call a template to show the result.

The action category can be used to filter or to group actions. For example you may want to show only a set of actions that are enabled on a document filtered by a category.

Finally, the guards can be installed to restrict actions to be available only for some users. Guards are very flexible. To define a guard you can use complex logical expressions on other guards. We will name any guard that it is not a logical expression an atomic guard.

Here is a list of all supported atomic guards:

+ Permission Guard - restrict access by testing native Nuxeo ECM document permissions.
+ User Guard - restrict access by testing the current user name
+ Group Guard - restrict access by testing the current group name
+ Type Guard - restrict access by testing the current document type
+ Schema Guard - restrict access by testing the presence of a schema in the current document type
+ Facet Guard - restrict access by testing the presence of a facet in the current document type
+ Script Guard - restrict access using random scripts. Any java scripting engine is supported

Example of a logical expression guard: `Write OR (user = titi OR group = toto )`. This means give permission on all users that have the `Write` permission on the document OR to user named `titi` or all user from group `toto`.  

You can define actions as you want: you can map them to scripts or to Java code - it is up to you how you will use that action.

For how to retrieve available actions on the target document from a script refer to the Script Context chapter.



== Configuration

The configuration files are located in `web/WEB-INF` directory.

The configuration files are hot deployable - this means you can modify configuration and have your modifications visible without restarting the server. The same is true for any script and template files. The only exception is the web.xml file which declares the servlet used by WebEngine when deployed as a standalone servlet.

*Note* that the configuration files syntax may change in future versions.

