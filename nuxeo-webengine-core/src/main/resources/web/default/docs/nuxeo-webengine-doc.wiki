
= Nuxeo WebEngine

{toc}{/toc}

The WebEngine is a framework to build web applications on top of the Nuxeo EP platform.

== Overview

The main goal for the WebEngine framework is to let users to build web applications quickly and easily and in a traditional way 
without having knowledge on advanced Java topics such as JSF or Seam.

The second goal is to be able to develop web pages while the server is running, without the need of restarting
the server each time the configuration or the code is modified.

The web pages are build using Freemarker templates for the presentation part and optionally scripts 
(like groovy, jython etc) or custom Java request handlers for the logical part.

Thus a web application is made from:
+ *Configuration* - based on the nuxeo extension points mechanism
+ *Templates* - freemarker is used as the template engine
+ *Scripts* - any script supported by java scripting engine.
+ *Custom Java Code* - plugged-in through extension points

Here is an example of a simple template page
{{{My name is ${Context.principal.name}!}}}
that is outputting
{{{My name is Administrator!}}}
if you are logged in as __Administrator__.

The same can be done from a script (in this example a groovy script):

{{{
Context.print("My name is ${Context.principal.name}")!
}}}



=== Bridging with Nuxeo EP

The WebEngine was created to work over a Nuxeo EP server. Using it outside Nuxeo EP is possible, but is very limiting and you will loose many of the cool features of the WebEngine.

If you don't plan to use a Nuxeo EP server as the content backend for your web site or Web 2.0 application, we suggest you to look at other products that may better fit your needs:
* Django
* Ruby on Rails
* etc.

In this section we will assume you have some knowledge about the Nuxeo EP platform.

Nuxeo EP, as its name suggests, is an Enterprise Content Management platform that provides a powerful way to manage and store your documents. For simplicity you can see Nuxeo EP as a document repository. To use access the repository, to update, query or to store new documents, you need first to connect to it and create an authenticated session based on your login information. Using that repository session you can then start querying, updating and sorting documents.

So, from a client point of view, the main concepts of a Nuxeo Repository are the Session (the user connection to the repository) and the Document (the units of information that are mananged by the repository).

The idea behind the WebEngine is to map HTTP requests to documents stored in the repository and to be able that way to query, update, store or create new documents by using a traditional Web approach.

To correctly understand how this bridging over Nuxeo EP is done and what you can do by using WebEngine, you should first understand how HTTP requests are dispatched, processed and mapped to documents.



=== Request Dispatch

We will start using a simple example. Let's say the client is requesting the following URL:
`http://www.nuxeo.org/nuxeo/site/repository/blogs/bstefanescu/MyBlog@@view`

First the URL will be split as following:
* `http://www.nuxeo.org` - the server host information
* `/nuxeo/site` - the servlet context path. This corresponds to the Java context path + servlet path. As we are in Java world, we are obviosuly using Java servlets under the hoods. The WebEngine is bound on an unique servlet in a Web Application. You cannot have multiple WebEngines in the same Web Application. If you want to partition your WebEngine sites into different applications you need to use the WebEngine Application concept as we will see later.
In the standalone packaging of WebEngine 9based on Jetty) the servlet context path is the root one: "/".
* `/repository` - the WebEngine application path. This path is used to select te WebEgnine application you want.
* `/blogs/bstefanescu/MyBlog` - the request path. This path is used to select the document or script you want to call.
* `@@view` - the action to take on the selected object. The action is optional and, if ommited when requesting Documents, the implicit action is `@@view`.

The first 2 URL components are not in the scope of this document. They are used to locate the servlet bound to the WebEngine application.

We will focus on the last two URL parts:

+ Application path
+ Request path
+ Action



==== Application Path

The application path is used to select which WebEngine application to use. WebEngine applications are usefull to isolate the different sites you want to host. A single application may define several application paths. When defining an application path you can optionally specify a repository Document that will be selected as the root document when an application is selected.\
More details about this in the WebEngine Application section.


==== Request Path

The request path (aka traversal path) represent the path that should be processed and resolved by the selected web application. If the application path used to select the application defined a Document root then the application will try to map the request path to a Document or a chain of Documents in the repository. If the application path is not bound to a Document root then the application will try to resolve the path to a script or template on the file system. If neither of these methods succeeds an error page (along with a 404 error code) is sent to the client.\
*Note* that in future it will be possible to bound an application path to an arbritrary root Object that is not necesarly a Document in the repository but that will know how to resolve the request path into a chain of arbitrary objects (not necesarly Documents). This is usefull for example to map a request path on an User, Group or other objects managed by Nuxeo EP.

The default technique to resolve request paths into a chain of Documents is using a direct mapping beetween the request path and a repository path starting from the root Document. The mapping technique is configurable and can be changed by implementing the `org.nuxeo.ecm.webengine.RequestHandler` interface.

Lets give an example on how the default mapping works.

Lets say you defined an application bound to an application path of `/repository` in the context of a WebEngine instance that is bound to a servlet accessible at `http://localhost:8080/nuxeo/site`.  So, a request of the form `http://localhost:8080/nuxeo/site/repository/foo/bar` will be resolved against your application and the URL will be split as following:

+ `http://localhost:8080` - host server
+ `/nuxeo/site` - WebEngine context path (the root context)
+ `/repository` - the application path
+ `/foo/bar` - the request path

Lets say your application path `repository` defines a root document that points to `/default-domain/workspaces/MyWorkspace` (this is a repository path).
Then the application will try to resolve the `/foo/bar` path as a repository path starting from te root Document. So the selected document (the target document of the request) will be one of:

* `/default-domain/workspaces/MyWorkspace` - the root itself
* `/default-domain/workspaces/MyWorkspace/foo` - if `foo` is resolved as a child document of the root but `bar` is not resolved as a child document of `foo`
* `/default-domain/workspaces/MyWorkspace/foo/bar` - if both `foo` and `bar` are resolved as child documents

Let say `foo` is a child of `/default-domain/workspaces/MyWorkspace` and `bar` could not be resolved as a child document of `foo`. Then the request path will be resolved to `/default-domain/workspaces/MyWorkspace/foo` that will be called the *Target Document* (or Context Document) and the remaining segments (the unresolved segments) will define the *trailing path* - in our case `/bar`. The chain of Documents that were obtained by mapping the request path is known as the *traversal objects*.


==== Trailing Path
As we've seen the trailing path contains the `residual` segments after a mapping on a Document is done. Obviously it will be empty if all segments from the request path are mapped to documents. Anyway, such 'residual' path segments are not garbage but they may give some extra information on how to perform the request. How the trailing path is used by the server is depending on the action or script that will be executed on the Target Document. There isn't any default behavior in handling such a trailing path. It is up to the developer how this path is used.
For example a possible usage is to map the trailing path on an XPATH that point to a Document property. So in our previous example the trailing path `/bar` will point to a property `bar` in the document `foo`. This can be used to create paths to set or get properties on documents. Example:
`/default-domain/workspaces/MyWorkspace/foo/bar@@set?value=test` 


==== Actions

The action string represent an action to be taken on the last resolved document (or the target document).

An action can be bound to a Java class (an action handler) or to a script in order to perform the wanted operation on the document.
If no action is specified in the request URL then a default action `@@view` will be used.

*Note* that in future the `action` concept will be extended. For now actions are used when requesting Documents. They are ignored when the request is not resolved to a document but to a script or template. (e.g. if you are using pure scripting that are not resolved to Nuxeo EP Documents). In future the action mechanism will be extended to be used on any type of resource. For example in the case of scripts an `action` may be mapped on a script function.

You can find more details on actions in Web Application : Actions section



=== Path Mapping

We already seen how the request URL is transformed into these components:
+ host server
+ servlet context
+ application path
+ request path
+ an optional trailing path
+ an optional action

In the examples above we've seen how a request path was mapped on documents. But what if we need more control on the mapping mechanism? As we said one solution (but harder) is to write a custom request handler that is doing the job. Another solution that doesn't requires any additional Java code is to use path mappings.

Mappings can be used to declaratively describe how request paths should be processed to obtain a document chain, a trailing path and additional properties computed from the path segments configuration. Mappings are described using regular expression patterns. The regular expression syntax is the Java one with an additional feature to be able to define named groups. (In Java only indexed groups are supported).

In order to understand how you can use patterns to describe the path mapping we will start with another example.

Lets say we want to use the following URL path:

`/blogs/archive/2004/05`

to display a list of the blogs of user `bstefanescu` created in May 2004. Lets say that we define an application path `/blogs` that specify a root Document `/default-domain/workspaces/blogs` where are stored the blogs in the repository.

So by using a `/blogs` prefix in the URL path we will seclect the correct application so that we have the root `/default-domain/workspaces/blogs`.
Then, we want to use a script that will be invoked in the context of the root document to perform a search like:
{{{SELECT * FROM Blog WHERE ecm:path STARTSWITH ${blogs} AND dc:created >= DATE '$year-$month-01'}}}
to select all the blog documents created after the given date and located under the `${blogs}` document.
For this we need to extract from the input the year and the month information. We already known the `${blogs}` variable since it is the target document of the request (in our case it is the same as the seclected application root).
In order to do this we need to define the following mapping:

{{{/blogs/archive/(?year:[0-9]{4}?)/(?month:[0-9]{2}?)}}}

This mapping is matching any path in the desired format and will inject in the request context the variables `${year}` and `${month}`. This way the script can grab them from the context and run the query.

The syntax (?label: ... ) for regular expression groups is an extension to the Java regular expressions that are supporting only indexed groups. You can still use the indexed groups if you prefer:

`/blogs/archive/([0-9]{4}?)/([0-9]{2}?)`

In this case the generated mapping variables will be `$1` for the year and `$2` for the month.

You may note that using mappings or using a custom request handler that avoid mapping path segments on documents you may create web application that doesn't use any Nuxeo repository.



=== Directory Layout - Resolving Scripts and Templates 

All WebEngine application files are residing under a common root folder named the web folder. This folder is located in `${nxserver}/web` folder in the standalone version. On JBoss the web root folder is located in `${jboss_install_dir}/server/default/data/NXRuntime/web`.

An application may have multiple roots folders where scripts and other files are residing. When resolving scripts from paths each of these folders are consulted in turn until a matching file is found.

Example: Let say you have an web application that contains two roots: `wiki` and `default` (in that order). So inside the `web` directory we will have `web/wiki` and `web/default`.

When resolving a path let say `/commons/myscript.py` the web application will look first in `wiki` folder for a file path `commons/myscript.py` and then if none was found it looks for the same path in the `default` folder. 

This mechanism is completely described in the Directory Stacking section.

Note that the paths `/commons/myscript.py` and `commons/myscript.py` are equivalent. Both of them will be resolved relative to the Web Application root folders.

If you need to use relative paths (relative to the current executed script or template) you must prepend a '.' or a '..' on the path to force the path resolver to use the current script as the file base.

Example of relative paths:
* ../../myscript.py
* ./myscript.groovy

Note that using relative paths is less efficient since the path lookup cannot be cached because the current directory used to resolve scripts depends on the current request context, context that is changing on each request or more may change during the same request.\
Also when a relative path points outside the web root directory then it will be truncated (i.e. trailing ../ removed) and resolved as an absolute path.

==== Resolving Action Scripts

When writing scripts or templates to handle request actions we usually want to treat the target documents of same type in the same manner. For example a `Folder` document will be always displayed as a folder, a `File` document as a file and so on.

So we need a mechanism to select the template or the script associated to an action depending on the target document type.

Note that this selection mechanism make sense only for document action scripts. It doesn't make sense for plain scripts (that are not bound to documents) since in this case you may not have a target document.

This aspect was solved by using a very simple and intuitive mechanism based on folder names:

Each application root folder may contain a sub-folder for each document type. This sub folder should use the same name as the document type.

This way each time an action script is resolved the resolver will look in the folder having the same name as the target document type. If it doesn't find any matching file it is looking in the folder corresponding to the super type of the current document type and so on. This lookup stops when a matching file is found or when no more super types exists.

As the `Document` type is the base types of all Nuxeo document types you may put in that folder the default files for every document action.

If no file matches then a default file (a fallback file) will be used to display a custom message. This default file is configurable at the application level. If the default file cannot be fond or was not defined then a 404 is send to the client.

Example: In the `default` application root you may have three folders:
* Document
* Folder
* Wiki

Let say you want to call the script bound to the `@@view` action of a `Wiki` document. Then the script resolver will first look into `Wiki` folder then if nothing is found and because `Wiki` is extending `Folder` it will look into `Folder` folder and then if nothing is found as `Folder` is extending `Document` it will look into Document folder. Finally if nothing is found the registered default script if any is used.

*Note* that when you have multiple web application roots this mechanism will searching the script in each root in turn until something is found.



== Getting Started

WebEngine is shipped in two flavours:
* a standalone server
* a Nuxeo EP module, that runs in a JBoss application server

Both of these versions provides the same functionalities and the same JARs are used on both platforms.
This is possible since WebEngine is build over the Nuxeo Runtime layer that works over any OSGi platform.
In both standalone and JBoss versions the OSGi framework is emulated by a Nuxeo component: `nuxeo-runtime-osgi`.

WebEngine is working on any platform supported by Nuxeo EP (UNIX-like systems, MAC OS X, Windows). Anyway in the case of MAC OS X there is a known problem and to be able to start WebEngine you need to remove the file `System/Library/Java/Extensions/AppleScriptEngine.jar` file.



=== Standalone server

The standalone server is the *light* version of WebEngine and doesn't requires an application server to work.
This means that Nuxeo services requried by WebEngine are not exposed as session beans. Anyway, all of the functionalities present in the JBoss version are available in the standalone server.
The light version is embedding a Jetty HTTP server and by default binds the WebEngine instance to the root web context: `/`.\
In the future, we plan to also provide a light version of WebEngine that will embed a GlassFish3 server.

The light version is very usefull for developing since the startup time is very fast (e.g. 2-3 seconds on my laptop using Java6) - but can be also used in production.

==== Installation
To install the light version download it from http://nuxeo.org/projects/webengine, unzip the content into a folder of your choice.
and run `nxserver.sh` to launch the application.

==== Launcher
To start WebEngine simply run `./nxserver.sh` on linux or `nxserver.cmd` on windows.

The common options are:

* `-debug` - to start in debug mode. In this mode the launcher will wait for a Java debuger to connect.
* `-clear` - to cleanup cache before starting. This is needed if you add a JAR into `bundles` or `lib` directories - since the launcher is caching the classpath at the first start of the server.

For more information on the launcher look into `nxserver.sh`

==== Requirements
* Java 5 or later - WebEngine is working fine on both Java 5 and 6.



=== Nuxeo EP module

WebEngine can be deployed as a Nuxeo EP module on a running Nuxeo server (that currently supports JBoss as application server).\
In this version, WebEgnine is bound by default to the `/nuxeo/site` context path.

When deployed as a Nuxeo EP module, WebEngine will run in an application server so all required Nuxeo services will be exposed as session beans.

==== Installation

Install a Nuxeo EP product. Download the webengine components from http://www.nuxeo.org/projects/webengine:
* nuxeo-platform-rendering
* nuxeo-webengine-core
* nuxeo-webengine-wiki (optional)

Copy these JARs inside nuxeo.ear/plugins

Make sure you have nuxeo-runtime-scripting in your nuxeo.ear/system folder if not download and copy it into this folder.
Make sure you have the following JARs in yout `nuxeo.ear/libs`:
* freemarker-2.3.11.jar
* json-lib-2.2.1-jdk15.jar
* ezmorph-0.9.jar

If they are not there, download them and copy into the `libs` folder (overwriting older versions if any)

In order to use Anonymous login you also need to deploy the optional Nuxeo EP module: `nuxeo-platform-anonymous-login`. In the standalone version this feature comes by default.

==== Requirements
* JBoss 4.0.5 GA
* Nuxeo EP 5.2 - WebEngine is not working with older versions
* Java 5 - WebEngine is also working with Java 6 but other modules in JBoss may not work properly.



== Applications

Now that we've seen the main concepts used to build a web application, we can learn how to configure and assemble them to obtain a working application.
 
A Web  Application is a collection of configuration files, scripts, templates and other resources that are accessible remotely through a servlet. The WebEngine allows the definition of multiple applications. All these application data reside inside the root `web` directory.

An application may access any resources within the root `web` directory, but none outside it. This means that several applications may share data and reuse scripts.

An application is responsible for:
+ Resolving script or templates paths
+ Managing the custom configuration
+ Resolving path segments to documents
+ Managing the scripting and template engine

Web application data may be contributed by separate OSGi modules (JARs). Usually when a module wants to contribute it's own scripts and templates it is installing these files from the JAR inside the `web` root directory (this is done automatically by using an extension point - we will see this later in Configuration chapter).

It is recommended that modules should contribute files by creating a new directory into the `web` root and not by replacing existing files. The directory stacking mechanism can be used to override existing files if this is wanted. 

Applications are usefull when you need to deploy multiple sites on the same server or when you want to customize an existing application but don't want your changes to modify the existing application. For example you need to override the document type `File` is handled vut only in your application scope.\
When hosting multiple sites using WebEngine it is better to separate these sites in applications rather than using a single application that will correctly dispatch request for each site by using mappings or other techniques. This ensure a better scalability since each application configuration is isolated from the others and each application will use its own cache.

Even if isolated at configuration level, applications may share script, template or static files.


=== Web Engine Servlet

All applications are served by a single servlet - the one that is bound in the web.xml file to the WebEngine. To create a WebEngine servlet you should define it as following (see `web/WEB-INF/web.xml` file):

{{{
  <servlet>
    <servlet-name>Nuxeo WebEngine Servlet</servlet-name>
    <servlet-class>
    org.nuxeo.ecm.webengine.servlet.WebServlet
    </servlet-class>
  </servlet>
}}}

To be able to use the Nuxeo EP repository from WebEngine you should also declare an authentication filter as following (see `web/WEB-INF/web.xml`)

{{{
  <filter>
    <display-name>WebEngine Authentication Filter</display-name>
    <filter-name>WebEngineAuthenticationFilter</filter-name>
    <filter-class>
      org.nuxeo.ecm.webengine.login.WebEngineAuthenticationFilter
    </filter-class>
    <init-param>
      <param-name>exclude</param-name>
      <param-value>/files</param-value>
    </init-param>
  </filter>
}}}

The `exclude` parameter is used to avoid filtering request having paths starting with the `/files` prefix since this prefix is used by WebEngine to locate static files as CSS, script and image files.


=== Application Configuration

Before talking about configuration format you should know that WebEngine is using the Nuxeo extension point mechanism to contribute configuration files.
A Nuxeo component may delcare several extension points to let other components contributing custom configuration. Tese extension poitns are declared using XML files. Extensions contributed by other modules are also declared as XML files. For more information on how this works see te documentation of Nuxeo EP.

To define a new application you need to contribute a new application extension. This extension can live anywhere where accessible from `nuxeo-webengine-core` bundle (even in a JAR) but we recommend to place configuration files in `web/WEB-INF` directory.

As new applications are usually contributed by new modules (that are installed as JARs) this section will explain how to create a new application from a nuxeo module.
A WebEngine module, apart the configuration files may also deploy script and other resource files in the `web` directory. Here is a a complete example on how to create a new application and deploye new web resources and it is taken from the `nuxeo-webengine-wiki` module. In your module you need to deploy an XML component having a content similar with the following (see `nuxeo-webegine-wiki/OSGI-INF/wiki-deployment-contrib.xml`):

{{{
  <extension
    target="org.nuxeo.ecm.webengine.WebEngineComponent"
    point="install">
      <install guard="/WEB-INF/wiki-webapp.xml">
        <copy path="OSGI-INF/wiki-webapp.xml" target="/WEB-INF/wiki-webapp.xml" />
        <copy path="web/wiki" target="/" />
        <copy path="web/resources" target="/" />
        <append path="web/i18n/messages.properties" target="/i18n/messages.properties"/>
    </install>
  </extension>

  <extension
    target="org.nuxeo.ecm.webengine.WebEngineComponent"
    point="configuration">
      <configuration path="/WEB-INF/wiki-webapp.xml" />
  </extension>
}}}

The first extension point is delcarin all the files you want to copy from the JAR in the `web` directory the first time your module is loaded.
The `copy`directive is doing a directory or file copy by overwriting any existing file; the append directive is appending some file on an existing file.

The special `guard` attribute is specifying a file that will act as a guard to prevent re-deploying your web files each time you restart the server.
That is,if the `guard` file already exists, then the file deployment is skiped. This way, the startup time is improved and also you avoid overwriting your manual changes on the already deployed files.

The second extension is declaring the `/WEB-INF/wiki-webapp.xml` as a configration file. This is also enabling the hot redeployment on that file.
If you don't want hot redeployment on your configuration file you need to add an extra attribute: *trackChanges="false"*

*Note* that it is also possible to deploy new applications without having to install a new JAR. To do this you need to edit an existing configuration file and add your application contribution there or to add a new configuration contribution (that declares your new configuration file). In future this will be improved and we plan to make possible to install and remove applications simply by adding / removing XML files into `web/WEB-INF`.

Now that you deployed you know how to deploy a new application we can look into the application extension point to see how an application can be configured.

Here is an example of an application configurtaion:

{{{
  <extension target="org.nuxeo.ecm.webengine.WebEngineComponent"
    point="application">
    <webapp id="myapp" extends="default">
      <repository>default</repository>
      <errorPage>error.groovy</errorPage>
      <roots>
        <root priority="0">default</root>
      </roots>
      <mappings>
        <mapping pattern="/search">
          <script>/common/search.ftl</script>
        </mapping>
      </mappings>
    </webapp>

  </extension>
}}}

* `extends` attribute is optional and means that the current application extends the configuration defined for the `default` application.\
* `repository` element is used to specify what repository this application will use (if any is used). It defaults to "default"
* `errorPage` element specify a script or template to be used to handle errors. It defaults to "error.ftl". There are also more default pages that you can configure using the elements:
** `indexPage` - called when a root request `/` is made in that application. Defaults to "index.ftl"
** `defaultPage` - called when a resource is not found and the application didn't triggered any error. Defaults to "default.ftl"
* `roots` used to declare the directory roots in that application. See Directory Stacking section for more information.
* `mappings` used to bypass the default mapping mechanism as discussed Path Mapping section. In our example the traversal path that exactly match `/search` will be redirected to the script `/common/searech.ftl`

*Note* that the configuration syntax may change in future.

=== Application Selection

We've seen how to define a new application. But how this application becomes selected for an incoming request?\
This is done by defining rules to map request paths to applications.\
*Note* that a single application can be mapped to multiple paths.\
Here is an example fo such a mapping rule:

{{{
  <extension target="org.nuxeo.ecm.webengine.WebEngineComponent"
    point="application-mapping">
    <mapping path="/" webapp="default" />
    <mapping path="/repository" webapp="default" document="/default-domain" default="true" />
  </extension>
}}}

The mapping is done on path prefixes and the longest match win.

The first mapping rule is mapping the __default__ application to any path that starts with `/` path. This means any requests that is not matched to an application will be handled by the default application.\
The second mapping rule is mapping the __default__ application to any path that starts with `/repository`.
Also the `document` attribute specify that when this rule matches the Document root should be set to `/default-domain`.
The `default` attribute is a little bit special. It tells that this mapping rule is the default one when trying to compute document paths.
Imagine in you display on a page the result of a search in the repository. Within the result you may have documents that are outside the scope of your application context. In order to be able to display such documents you need an URL (that your application is not aware of). In that case the `default` mapping rule will be used to compute the document URL.

For more details about what can be configured in both configuration layers see the Configuration chapter.


=== Directory Stacking

As we've seen earlier an application may define several roots inside the web root directory.

These roots are known as the application directory stack and are used to resolve scripts and templates.

Root directories are stacked given a priority so that the resolver will try each root in a the right priority order until a resource is found.

Directory Roots are mainly used to override templates and scripts or add new ones from external modules. By using the right priority for the root directories in the stack you may obtain the desired effect - overriding some existing resources without overriding some other ones.

Stacking is inherited when an application extends another application.

==== Example

Let's say module nuxeo-webengine-core contributed the `default` directory, nuxeo-webengine-wiki contributed the `wiki` directory and nuxeo-webengine-blogs the `blogs` directory.

The `wiki` folder contains scripts and templates that deals with `Wiki` and `WikiPage` document types, while the `blogs` folder declare the 
Then an application APP1 may use a stack: `wiki`, `default` and another application APP2 may use: `blogs`, `default`.
Both APP1 and APP2  will see the scripts that deal with common Nuxeo types (the ones from `default`) but APP1 will not see blog related scripts and APP2 will not see wiki related scripts.

Using the same mechanism you may change or hide only .css or .gif files creating thus skins.

=== Web Objects

Before talking about Web Objects we will recapitulate some things about traversal paths. We've seen that *request paths* are split into:
* an *application path*
* a *traversal path*
* and optionally a *trailing path*

The `traversal path` if any defines a sequence of documents that should be traversed before executing the request. The last document that is traversed (the last in the traversal object chain) is considered the target document of the request (this may be the root document itself) and the request will be executed in the context of that document.

We've also seen that you may have requests that doesn't generate any traversal path. In this case pure web scripting will be done (outside any document context). Also you should note that the documents in the traversal path are not necessarily the children of each other like in a repository path. The mechanism used to create the traversal path is up to the registered document resolver.

The documents in the traversal path will not be exposed as is in the request context but they will be wrapped inside a high level object - web oriented that is called WebOject. THis is needed because the Nuxeo documents are repository oriented, they doesn't have any knowledge about the web context in which they are used. They doesn't know for example what is the URL  used to access them, or what are the web actions that are enabled in the current web context.

For this reason before being exposed in the web context they are wrapped in a web sensitive object.

This means we need to map documents to a high level object that can hold web specific configuration like enabled web actions. 
This mapping can be done either at the global level XXX. 

=== Actions

There are several pre-defined actions in the default webengine configuration. Here is a list of that actions:

+ view
+ print
+ edit
+ delete
+ create
+ update
+ getfile
+ addfile
+ deletefile

An action should be identified using a meaningful verb like 'doSomething' and can specify:
* a class to be used as the action handler
* a script to be invoked on the target document
* an enablement flag to be used to disable / enable the action
* a category that can be used to group actions
* a set of guards to restrict the action execution

Any of these action properties are optional - but the action will be useless if you do not specify one of them.

The first 2 properties the *action handler* and the *script* should be used to specify how the action will be executed.

As you seen you have two options: either using java code (if you want faster or advanced processing) either using a script (possibly a template) that will carry on the action execution. 

You can either use both properties to install a Java action execution handler and a template to be used to show the result of the execution. Or, more, you can install a handler and a groovy script then in the groovy script you may do some post processing and then call a template to show the result.

The action category can be used to filter or to group actions. For example you may want to show only a set of actions that are enabled on a document filtered by a category.

Finally, the guards can be installed to restrict actions to be available only for some users. Guards are very flexible. To define a guard you can use complex logical expressions on other guards. We will name any guard that it is not a logical expression an atomic guard.

Here is a list of all supported atomic guards:

+ Permission Guard - restrict access by testing native Nuxeo EP document permissions.
+ User Guard - restrict access by testing the current user name
+ Group Guard - restrict access by testing the current group name
+ Type Guard - restrict access by testing the current document type
+ Schema Guard - restrict access by testing the presence of a schema in the current document type
+ Facet Guard - restrict access by testing the presence of a facet in the current document type
+ Script Guard - restrict access using random scripts. Any java scripting engine is supported

Example of a logical expression guard: `Write OR (user = titi OR group = toto )`. This means give permission on all users that have the `Write` permission on the document OR to user named `titi` or all user from group `toto`.  

You can define actions as you want: you can map them to scripts or to Java code - it is up to you how you will use that action.

For how to retrieve available actions on the target document from a script refer to the Script Context chapter.



== Configuration

The configuration files are located in `web/WEB-INF` directory.

The configuration files are hot deployable - this means you can modify configuration and have your modifications visible without restarting the server. The same is true for any script and template files. The only exception is the web.xml file which declares the servlet used by WebEngine when deployed as a standalone servlet.

*Note* that the configuration files syntax may change in future versions.

