About
-----

This module should be used to build Nuxeo products.

The created artifact are not suitable to be published online since a build
project may generate different ZIP artifacts depending on the profile used.

Building predefined applications
--------------------------------

Using this project you can build the following applications:

1. Nuxeo Shell 

  A client application suitable to connect on remote nuxeo servers.
  This application can be used to connect to remote nuxeo servers for debugging,
  browsing or administration stuff.

  Build syntax: `mvn package` or `mvn package -P shell`
    
2. Nuxeo Core Server 

  A minimal server application. An embedded repository will be started. No other
  platform services are available.
  
  This application can be used to debug, test or develop nuxeo components that
  need a repository connection.
  
  Remoting will be also available in the future via Nuxeo Runtime.
  
  Build syntax: `mvn package -P core`
    
3. Nuxeo Jetty Server
  
  A Nuxeo server application embedding a Jetty server. 
  
  This application can be used to browse repository content via WEB.
  
  This is also known as Nuxeo WebEngine (based on Jetty).

  Build syntax: `mvn package -P jetty`
   
4. Nuxeo GF3 Server
  
  A Nuxeo server application embedding a GlassFish v3 server. 
  
  This application can be used to browse a repository content via the web.
  
  This is also known as Nuxeo WebEngine (based on GF3).
   
  In the future, this application will provide a full installation of Nuxeo
  (including EJBs, JMS, etc).

  Build syntax: `mvn package -P gf3`
  
Extending
---------

This project manages the build of standalone Nuxeo applications such as nxshell
and WebEngine.

The build logic is slightly different from the nuxeo.ear build and is more
adapted for light packagings composed of well defined nuxeo artifact subsets.

The main difference is the way the final ZIPs are assembled. Instead of using
assembly descriptor inheritance, the final ZIP is assembled from several
prebuilt ZIPs by using an assembly descriptor.

Let's see for example how webengine based on jetty is built: as webengine is
using nxshell infrastructure, it need to share with this project the basic
infrastructure. On this skeleton it should add server specific artifacts and
configuration. Then it should add jetty specific config and JARs.

All these intermediate builds should be reusable to build other applications
like webengine based on GlassFish v3 or even nxshell itself.

To do this, 5 projects were created:

- A: nuxeo-application-base - contains basic skeleton of a standalone
application)

- B: nuxeo-shell-template - that modify the ZIP generated by A (by
adding/overriding or removing entries)

- C: nuxeo-server-template - that modify the ZIP generated by A by
adding server related artifacts and configuration

- D: nuxeo-jetty-template - that modify the ZIP generated by C by adding
jetty specific JARs and configuration

- E: nuxeo-gf3-template - that modify the ZIP generated by C by adding
GF3 specific JARs and configuration

This way the build is reused more easily than by using assembly inheritance
since any modification on an intermediate artifact (ZIP) is automatically
visible in the projects that are overriding the artifact.

NB: we are not using for now categories since the projects are not so complex to
manage by using explicit dependencies in assembly files. Also, existing
categories may not fit well with the kind of build done for nxshell or
webengine.

Maybe in the future we will use categories too, if projects become too complex.
